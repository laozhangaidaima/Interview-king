export let browser = [
  {
    title: "常见浏览器内核",
    msg: `
## 内核
- Trident：IE 浏览器内核；
- Gecko：Firefox 浏览器内核；
- Presto：Opera 浏览器内核；
- Webkit：Safari 浏览器内核；
- Blink：谷歌浏览器内核，属于 Webkit 的一个分支，与 Opera 一起在研发；

## 浏览器
- IE：Trident，IE 内核；
- Chrome：以前是 Webkit，现在是 Blink 内核；
- Firefox：Gecko 内核；
- Safari：Webkit 内核；
- Opera：一起是 Presto，现在是 Blink 内核；
- 360、猎豹浏览器内核：IE + Blink 双内核；
- 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；
- 百度浏览器、世界之窗内核：IE 内核；
- 2345 浏览器：以前是 IE 内核，现在是 IE + Blink 双内核；
- UC 浏览器内核：Webkit + Trident；
`,
  },
  {
    title: "页面导入样式时，使用 link 和 @import 有什么区别",
    msg: `
1. 从属关系区别。@import 只能导入样式表，link 还可以定义 RSS、rel 连接属性、引入网站图标等；
2. 加载顺序区别；加载页面时，link 标签引入的 CSS 被同时加载；@import 引入的 CSS 将在页面加载完毕后被加载；
3. 兼容性区别；
      `,
  },
  {
    title: "浏览器的渲染原理",
    msg: `

1. 首先解析收到的文档，根据文档定义构建一颗 DOM 树，DOM 树是由 DOM 元素及属性节点组成的；
2. 然后对 CSS 进行解析，生成 CSSOM 规则树；
3. 根据 DOM 树和 CSSOM 规则树构建 Render Tree。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 对象相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。
4. 当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情就是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。
5. 布局阶段结束后是绘制阶段，比那里渲染树并调用对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。


为了更好的用户体验，渲染引擎会尽可能早的将内容呈现到屏幕上，并不会等到所有的 html 解析完成之后再去构建和布局 render tree。它是解析完一部分内容就显示一部分内容，同时可能还在网络下载其余内容。
      `,
  },
  {
    title: "如何实现浏览器内多个标签页之间的通信",
    msg: `

实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者来让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。

1. 使用 Websocket，通信的标签页连接同一个服务器，发送消息到服务器后，服务器推送消息给所有连接的客户端；
2. 可以地调用 localStorage，localStorage 在另一个浏览上下文里被添加、修改或删除时，它都会触发一个 storage 事件，我们可以通过监听 storage 事件，控制它的值来进行页面信息通信；
3. 如果我们能够获得对应标签页的引用，通过 postMessage 方法也是可以实现多个标签页通信的；
      `,
  },
  {
    title: "简述前端性能优化",
    msg: `

## 页面内容方面

1. 通过文件合并、css 雪碧图、使用 base64 等方式来减少 HTTP 请求数，避免过多的请求造成等待的情况；
2. 通过 DNS 缓存等机制来减少 DNS 的查询次数；
3. 通过设置缓存策略，对常用不变的资源进行缓存；
4. 通过延迟加载的方式，来减少页面首屏加载时需要请求的资源，延迟加载的资源当用户需要访问时，再去请求加载；
5. 通过用户行为，对某些资源使用预加载的方式，来提高用户需要访问资源时的响应速度；

## 服务器方面

1. 使用 CDN 服务，来提高用户对于资源请求时的响应速度；
2. 服务器端自用 Gzip、Deflate 等方式对于传输的资源进行压缩，减少传输文件的体积；
3. 尽可能减小 cookie 的大小，并且通过将静态资源分配到其他域名下，来避免对静态资源请求时携带不必要的 cookie；
      `,
  },
  {
    title: "从输入一个url到浏览器页面展示都经历了哪些过程？",
    msg: `

1. 首先，在浏览器地址栏中输入url

2. 浏览器先查看浏览器缓存-系统缓存-路由器缓存，如果缓存中有，会直接在屏幕中显示页面内容。若没有，则跳到第三步操作。

3. 在发送http请求前，需要域名解析(DNS解析)，解析获取相应的IP地址。

4. 浏览器向服务器发起tcp连接，与浏览器建立tcp三次握手。

5. 握手成功后，浏览器向服务器发送http请求，请求数据包。

6. 服务器处理收到的请求，将数据返回至浏览器

7. 浏览器收到HTTP响应

8. 读取页面内容，浏览器渲染，解析html源码

9. 生成Dom树、解析css样式、js交互

10. 客户端和服务器交互

11. ajax查询
      `,
  },
  {
    title: "tcp三次握手",
    msg: `
1. 第一次握手：客户端发包，服务端收到了
2. 第二次握手：服务端发包，客户端收到了
3. 第三次握手：客户端发包，服务端收到了
- 作用是：客户端和服务端都确认自己的接收、发送能力是正常的
- TCP连接是全双工 需要确认双方接收、发送能力都是正常的
      `,
  },
  {
    title: "tcp四次挥手",
    msg: `
1. 第一次挥手：客户端请求关闭连接。
2. 第二次挥手：服务器端还没有准备好关闭连接。
3. 第三次挥手：服务器端准备好关闭连接时，通知客户端
4. 第四次挥手：客户端确定关闭，服务端确定关闭
- 作用是：告诉对方我要关闭了
      `,
  },
  {
    title: "浏览器渲染过程",
    msg: `
1. HTML解析出DOM树
2. CSS解析出css树
3. 将二者关联生成渲染树
4. 根据渲染树计算每个节点的信息
5. 根据计算好的信息绘制整个页面

- 其他特点
  - 浏览器解析文档，当遇到script标签的时候，会立即解析脚本，停止解析文档（因为JS可能会改动DOM和CSS，所以继续解析会造成浪费）。
  - html从上往下渲染

      `,
  },
  {
    title: "重绘和回流,如何进行优化？",
    msg: `
- 重绘
  - 不影响布局：color、background-color、outline
- 回流
  - 布局改变：元素大小、布局、隐藏
  1. 添加或者删除可见的DOM元素；
  2. 元素位置改变；
  3. 元素尺寸改变——，margin、padding、height、width；
  4. 内容变化，比如用户在input框中输入文字，文本或者图片大小改变而引起的计算值宽度和高度改变；
  5. 页面渲染初始化；

- 其他特点
  - 回流必将引起重绘，而重绘不一定会引起回流。
  - html从上往下渲染
- 优化
  1. 避免设置多层内联样式
  2. 避免使用table布局
  3. 避免频繁操作DOM
  4. 多用class 少用id
      `,
  },
  {
    title: "前端SEO",
    msg: `
1. 准确的网页标题 title
2. 使用 meta 元标签  keywords和description要准确
3. 使用语义化元素
4. 利用 img 中的 alt 属性
5. html css js 样式分离
6. 重要内容放在html最前面
7. 速度 / 性能直接影响 SEO
      `,
  },
];

export let server = [
  {
    title: "HTTP状态码作用",
    msg: `
- 1xx消息
    - 处理中
- 2xx成功
    - 服务器处理成功
- 3xx重定向
    - 客户端采取进一步的操作才能完成请求。
- 4xx客户端错误
    - 客户端错误
- 5xx服务器错误
    - 服务器错误
`,
  },
  {
    title: "DNS缓存",
    msg: `
1. DNS查询耗时大约20ms
2. 过期时间：谷歌、火狐 1分钟  IE将DNS缓存30min  iOS 24小时
- 作用是：将域名解析成IP地址
      `,
  },
  {
    title: "CDN缓存",
    msg: `
- 作用是：内容分发网络 中间服务器 提高异地访问速度
      `,
  },
  {
    title: "浏览器缓存(http缓存)",
    msg: `
1. 将资源缓存到内存中
2. 三级缓存原理 (访问缓存优先级)
   1. 先在内存中查找,如果有,直接加载。
   2. 如果内存中不存在,则在硬盘中查找,如果有直接加载。
   3. 如果硬盘中也没有,那么就进行网络请求。
   4. 请求获取的资源缓存到硬盘和内存。
3. 浏览器缓存的分类
   1. 强缓存
   2. 协商缓存
4. 浏览器默认缓存时间
   1. firefox ：假设 7点0分 访问的 5点0分修改的 index.html ,那么缓存时间为2*60*60 ÷ 10 = 720 秒 页面缓存时间为 720 秒
5. Expires：过期时间
6. ETag：文件发生了改变
7. Cache-Control：设置缓存时间、状态以及验证状态。
8. Last-Modified：上次被修改时间
- 作用是：保存HTTP获取的资源 减少服务器负担 加快网页速度
      `,
  },
];

export let html = [
  {
    title: "Doctype作用",
    msg: `
- 作用是：告诉浏览器用怪异模式还是标准模式解析

1. 标准模式：遵循最新标准
2. 怪异/兼容模式：处理所有奇怪的渲染及不符合标准的网页。
3. 强制触发怪异模式
    1. 丢失的 URL
    2. 没有使用或格式错误的 DOCTYPE
`,
  },
  {
    title: "标准模式和怪异模式区别",
    msg: `
1. 标准盒模型：width = width + 2margin + 2padding + 2*border 
2. 怪异(ie)盒模型：width(content) 部分包含了 border 和 padding  注意：margin不包括
3. 切换盒模型： 
    1. 怪异盒模型：box-sizing："border-box"  
    2. 标准盒模型：box-sizing："content-box"
`,
  },
  {
    title: "行内元素有哪些?块级元素有哪些?怎么改变？",
    msg: `
1. 块级元素：div h1--h4 hr ul li
2. 行内元素: span img input i a em  
3. 切换元素类型： 
    1. 块级元素：display：block  
    2. 行内元素：display：inline
`,
  },
];
